<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Traceroute im Browser – RawOutput hübsch</title>
<style>
  :root { --bg:#f6f8fa; --card:#fff; --bd:#e2e5e9; --muted:#667; }
  body { margin:0; padding:24px; background:var(--bg); font-family:Verdana, Arial, sans-serif; }
  .card { background:var(--card); border:1px solid var(--bd); border-radius:14px; padding:18px; max-width:1100px; margin:0 auto 18px; }
  h1 { margin:0 0 12px; font-size:22px; }
  label { display:block; font-weight:600; margin:10px 0 6px; }
  input, select, button { padding:8px 10px; margin-right:6px; }
  button { cursor:pointer; }
  .muted { color:var(--muted); font-size:0.92rem; }
  .pill { display:inline-block; padding:2px 10px; border:1px solid var(--bd); border-radius:999px; background:#fff; margin-right:6px; font-size:0.85rem; }
  table { width:100%; border-collapse:collapse; margin-top:10px; }
  th, td { border:1px solid var(--bd); padding:8px; text-align:left; vertical-align:top; }
  th { background:#f2f4f6; }
  tr:nth-child(even) { background:#fafbfc; }
  .rtts { display:flex; flex-wrap:wrap; gap:6px; }
  .rtt { border:1px solid var(--bd); border-radius:6px; padding:2px 8px; font-family:monospace; }
  .timeout { color:#b00020; }
  details { margin-top:10px; }
  pre { background:#222; color:#eee; padding:10px; border-radius:8px; overflow:auto; }
  .ok { color:#0a7c2f; }
  .err { color:#b00020; }
</style>
</head>
<body>

<div class="card">
  <h1>Traceroute – Darstellung nur aus RawOutput</h1>
  <div class="muted">
    Diese Seite startet eine Globalping-Messung und parst ausschließlich die Textausgabe (<em>rawOutput</em>).
    Hostnamen werden angezeigt, wenn sie in der Ausgabe enthalten sind (z.&nbsp;B. <code>host.example.net (203.0.113.5)</code>).
  </div>

  <label for="target">Ziel (Domain oder IP)</label>
  <input id="target" size="32" placeholder="z.B. example.com oder 8.8.8.8" value="8.8.8.8" />

  <label for="loc">Standorte (optional)</label>
  <input id="loc" size="38" placeholder='z.B. "DE", "EU", "US+AWS" oder leer lassen' />

  <label for="proto">Protokoll</label>
  <select id="proto">
    <option value="tcp" selected>TCP</option>
    <option value="icmp">ICMP</option>
    <option value="udp">UDP</option>
  </select>

  <label for="port">Port (nur TCP)</label>
  <input id="port" type="number" min="1" max="65535" value="443" style="width:90px" />

  <div style="margin-top:8px">
    <button id="run">Traceroute starten</button>
    <span id="status" class="muted"></span>
  </div>
</div>

<div id="results"></div>

<script>
const API_BASE = "https://api.globalping.io/v1";
const $ = (s) => document.querySelector(s);
const results = $("#results");
const statusEl = $("#status");

/* -------- RawOutput-Parser: erzeugt [{ ttl, probes:[{host, ip, rttMs}|{timeout:true}] }] -------- */
function parseRawTraceroute(raw) {
  if (!raw) return [];
  const lines = raw.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const hops = [];

  for (const line of lines) {
    // Hop-Zeilen beginnen fast immer mit der Hop-/TTL-Nummer
    const mTtl = line.match(/^\s*(\d+)\s+(.*)$/);
    if (!mTtl) continue;
    const ttl = parseInt(mTtl[1], 10);
    const rest = mTtl[2];

    // reine Sterne = keine Antwort (Timeout/Filter)
    if (/^(?:\*+\s*)+$/.test(rest)) {
      hops.push({ ttl, probes: [{ timeout:true }, { timeout:true }, { timeout:true }] });
      continue;
    }

    // Versuche Hostname + IP (Unix-Stil): "host.example.net (192.0.2.1)  10.0 ms  10.2 ms ..."
    const hostIpUnix = rest.match(/([a-z0-9\-_.]+)\s+\((\b\d{1,3}(?:\.\d{1,3}){3}\b)\)/i);

    // Windows-Stil (tracert -d): " 1   11 ms  12 ms  12 ms  192.168.1.1"  (ohne Hostnamen)
    // Windows-Stil (tracert mit Namen): " 1    1 ms    1 ms    1 ms  router.home [192.168.1.1]"
    const hostIpWin = rest.match(/([a-z0-9\-_.]+)\s+\[(\b\d{1,3}(?:\.\d{1,3}){3}\b)\]/i);

    let host = null, ip = null;
    if (hostIpUnix) { host = hostIpUnix[1]; ip = hostIpUnix[2]; }
    else if (hostIpWin) { host = hostIpWin[1]; ip = hostIpWin[2]; }

    // Fallback: irgendeine IP (falls keine Klammer-Notation vorhanden)
    if (!ip) {
      const ipOnly = rest.match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
      if (ipOnly) ip = ipOnly[0];
    }

    // RTTs extrahieren
    const rttRe = /(\d+(?:\.\d+)?)\s*ms/ig;
    const rtts = [];
    let rm; while ((rm = rttRe.exec(rest)) !== null) rtts.push(parseFloat(rm[1]));

    const probes = [];
    if (rtts.length > 0) {
      rtts.forEach(v => probes.push({ host, ip, rttMs: v }));
    } else if (ip) {
      probes.push({ host, ip, rttMs: null });
    } else {
      // Keine IP/RTT erkennbar → als Timeouts interpretieren
      probes.push({ timeout:true });
    }

    hops.push({ ttl, probes });
  }
  return hops;
}

/* -------- Rendering -------- */
function renderProbeCard(res, idx) {
  const probe = res.probe || {};
  const raw = res?.result?.rawOutput || "";

  const wrap = document.createElement("div");
  wrap.className = "card";

  const header = document.createElement("div");
  header.innerHTML = `
    <div><strong>Probe #${idx+1}</strong>
      ${probe.city ? `<span class="pill">${probe.city}</span>` : ""}
      ${probe.country ? `<span class="pill">${probe.country}</span>` : ""}
      ${probe.network ? `<span class="pill">${probe.network}</span>` : ""}
      ${probe.asn ? `<span class="pill">AS${probe.asn}</span>` : ""}
    </div>
    <div class="muted">Status: ${res.status || "unbekannt"} — Darstellung aus <em>rawOutput</em> geparst</div>
  `;
  wrap.appendChild(header);

  const hops = parseRawTraceroute(raw);
  const table = document.createElement("table");
  table.innerHTML = `<thead>
    <tr><th>Hop</th><th>Server</th><th>RTT-Messungen</th></tr>
  </thead>`;
  const tb = document.createElement("tbody");

  hops.forEach(h => {
    // Namen + IPs zusammenstellen (oft 1 Host/IP pro Hop)
    const labels = [];
    const seen = new Set();
    h.probes.forEach(p => {
      if (p && !p.timeout) {
        const label = p.host ? `${p.host} (${p.ip || "?"})` : (p.ip || "?");
        if (!seen.has(label)) { labels.push(label); seen.add(label); }
      }
    });
    const serverText = labels.length ? labels.join(" | ") : "–";

    // RTTs darstellen
    const rttBox = document.createElement("div");
    rttBox.className = "rtts";
    if (!h.probes.length || h.probes.every(p => p.timeout)) {
      const span = document.createElement("span");
      span.className = "rtt timeout";
      span.textContent = "* * *";
      rttBox.appendChild(span);
    } else {
      h.probes.forEach(p => {
        const span = document.createElement("span");
        span.className = "rtt";
        span.textContent = (p.timeout ? "*"
                          : (typeof p.rttMs === "number" ? `${p.rttMs.toFixed(2)} ms`
                          : (p.rttMs == null ? "–" : `${p.rttMs} ms`)));
        if (p.timeout) span.classList.add("timeout");
        rttBox.appendChild(span);
      });
    }

    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${h.ttl}</td><td>${serverText}</td>`;
    const tdR = document.createElement("td");
    tdR.appendChild(rttBox);
    tr.appendChild(tdR);
    tb.appendChild(tr);
  });

  table.appendChild(tb);
  wrap.appendChild(table);

  const det = document.createElement("details");
  det.innerHTML = `<summary>Rohausgabe anzeigen</summary><pre>${escapeHtml(raw)}</pre>`;
  wrap.appendChild(det);

  return wrap;
}

function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

/* -------- API-Aufruf & Polling -------- */
$("#run").addEventListener("click", async () => {
  const target = $("#target").value.trim();
  const loc = $("#loc").value.trim();
  const proto = $("#proto").value;
  const port = parseInt($("#port").value, 10) || 443;

  if (!target) { alert("Bitte ein Ziel angeben."); return; }

  results.innerHTML = "";
  setStatus("Messung wird gestartet …");

  // Nur gültige Felder verwenden!
  const body = {
    target,
    type: "traceroute",
    measurementOptions: {
      protocol: proto
      // Optional: ipVersion: 4 oder 6, falls du fest pinnen willst
      // ipVersion: 4
    }
  };
  if (proto === "tcp") body.measurementOptions.port = port;
  if (loc) body.locations = [{ magic: loc }];

  try {
    const create = await fetch(`${API_BASE}/measurements`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });
    if (!create.ok) {
      const txt = await create.text();
      throw new Error(`POST /measurements: ${create.status} – ${txt}`);
    }
    const created = await create.json();

    const id = created.id || created.uuid || created.measurementId || created?.results?.[0]?.measurementId;
    if (!id && created.results) {
      // Sofort-Ergebnis
      renderResults(created.results);
      setStatus("Fertig.", true);
      return;
    }
    if (!id) throw new Error("Konnte measurement id nicht ermitteln.");

    // Polling bis fertig
    await poll(id, 900, 30);
    setStatus("Fertig.", true);
  } catch(e) {
    setStatus(e.message, false);
  }
});

async function poll(id, intervalMs, max) {
  for (let i=0;i<max;i++){
    setStatus(`Hole Ergebnisse … (${i+1}/${max})`);
    const r = await fetch(`${API_BASE}/measurements/${encodeURIComponent(id)}`);
    if (!r.ok) throw new Error(`GET /measurements/${id}: ${r.status}`);
    const j = await r.json();

    if (Array.isArray(j.results) && j.results.length) {
      renderResults(j.results);
      const done = j.results.every(x => x.status && x.status !== "in_progress");
      if (done) return;
    }
    await new Promise(res => setTimeout(res, intervalMs));
  }
}

function renderResults(arr){
  results.innerHTML = "";
  if (!arr || !arr.length) {
    results.innerHTML = `<div class="card"><div class="err">Keine Ergebnisse.</div></div>`;
    return;
  }
  arr.forEach((res, i) => results.appendChild(renderProbeCard(res, i)));
}

function setStatus(t, ok){
  statusEl.textContent = t;
  statusEl.className = ok===undefined ? "muted" : (ok ? "ok" : "err");
}
</script>
</body>
</html>
